#!/usr/bin/env node

/**
 * Module dependencies.
 */

const app = require('../app');
const debug = require('debug')('socketiospeed:server');
const http = require('http');
const server = require('http').Server(app);
const io = require('socket.io')(server);
const fs = require('fs');

//console.log(fs.readFileSync("./public/javascripts/ammo.js",{encoding:'utf8'}));
eval(fs.readFileSync("./public/javascripts/ammo.js",{encoding:'utf8'}));
//console.log(Ammo);
//const Ammo = require('../public/javascripts/ammo.js');
Ammo().then((Ammo)=> {
  // Adapted from HelloWorld.cpp, Copyright (c) 2003-2007 Erwin Coumans  http://continuousphysics.com/Bullet/

  const main = ()=> {
    //console.log(Ammo);
    const collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
        dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
        overlappingPairCache    = new Ammo.btDbvtBroadphase(),
        solver                  = new Ammo.btSequentialImpulseConstraintSolver(),
        dynamicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    dynamicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));

    const groundShape     = new Ammo.btBoxShape(new Ammo.btVector3(50, 50, 50)),
        bodies          = [],
        groundTransform = new Ammo.btTransform();

    groundTransform.setIdentity();
    groundTransform.setOrigin(new Ammo.btVector3(0, -56, 0));

    (()=> {
      var mass          = 0,
          isDynamic     = (mass !== 0),
          localInertia  = new Ammo.btVector3(0, 0, 0);

      if (isDynamic)
        groundShape.calculateLocalInertia(mass, localInertia);

      var myMotionState = new Ammo.btDefaultMotionState(groundTransform),
          rbInfo        = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, groundShape, localInertia),
          body          = new Ammo.btRigidBody(rbInfo);

      dynamicsWorld.addRigidBody(body);
      bodies.push(body);
    })();


    (() =>{
      var colShape        = new Ammo.btSphereShape(1),
          startTransform  = new Ammo.btTransform();
      
      startTransform.setIdentity();

      var mass          = 1,
          isDynamic     = (mass !== 0),
          localInertia  = new Ammo.btVector3(0, 0, 0);
      
      if (isDynamic)
        colShape.calculateLocalInertia(mass,localInertia);

      startTransform.setOrigin(new Ammo.btVector3(2, 10, 0));
    
      var myMotionState = new Ammo.btDefaultMotionState(startTransform),
          rbInfo        = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia),
          body          = new Ammo.btRigidBody(rbInfo);

      dynamicsWorld.addRigidBody(body);
      bodies.push(body);
    })();

    const trans = new Ammo.btTransform(); // taking this out of the loop below us reduces the leaking

    for (let i = 0; i < 135; i++) {
      dynamicsWorld.stepSimulation(1/60, 10);
      
      bodies.forEach((body)=> {
        if (body.getMotionState()) {
          body.getMotionState().getWorldTransform(trans);
          console.log("world pos = " + [trans.getOrigin().x().toFixed(2), trans.getOrigin().y().toFixed(2), trans.getOrigin().z().toFixed(2)]);
        }
      });
    }

    // Delete objects we created through |new|. We just do a few of them here, but you should do them all if you are not shutting down ammo.js
    // we'll free the objects in reversed order as they were created via 'new' to avoid the 'dead' object links
    Ammo.destroy(dynamicsWorld);
    Ammo.destroy(solver);
    Ammo.destroy(overlappingPairCache);
    Ammo.destroy(dispatcher);
    Ammo.destroy(collisionConfiguration);

    console.log('ok.')
  }

  main();
});

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3003');
app.set('port', port);

/**
 * Create HTTP server.
 */

//var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string' ?
    'Pipe ' + port :
    'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ?
    'pipe ' + addr :
    'port ' + addr.port;
  debug('Listening on ' + bind);
}

const px = {},
py = {},
pz = {};
const names = [];

for (let i = 0; i < 100; i++) {
  names[i] = i;
  px[names[i]]=0;
  py[names[i]]=0;
  pz[names[i]]=0;
}

io.on('connection', (socket) => {
  console.log('a user connected');
  socket.on('getPos', (data) => {
    //console.dir(data);
    const obj = {};
    obj.name = data.name;
    obj.x = px[data.name];
    obj.y = py[data.name];
    obj.z = pz[data.name];
    io.emit('pos', obj);
    if(data.name == 99) {
      console.log(obj);
    }
    //console.log(obj);
  });
});

setInterval(() => {
  for (let name of names) {
    px[name] += Math.random();
    pz[name] = Math.random()*5;
    py[name] += 0.1 + Math.random();
    if (py[name] > 100) {
      py[name] = 0;
    }
    if (px[name] > 100) {
      px[name] = -200;
    }
  }
}, 10);